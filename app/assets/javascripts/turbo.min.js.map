{"version":3,"file":"turbo.min.js","sources":["../../javascript/turbo/cable.js","../../javascript/turbo/cable_stream_source_element.js","../../../node_modules/@rails/actioncable/src/adapters.js","../../../node_modules/@rails/actioncable/src/logger.js","../../../node_modules/@rails/actioncable/src/connection_monitor.js","../../../node_modules/@rails/actioncable/src/internal.js","../../../node_modules/@rails/actioncable/src/connection.js","../../../node_modules/@rails/actioncable/src/subscription.js","../../../node_modules/@rails/actioncable/src/subscription_guarantor.js","../../../node_modules/@rails/actioncable/src/subscriptions.js","../../../node_modules/@rails/actioncable/src/consumer.js","../../../node_modules/@rails/actioncable/src/index.js"],"sourcesContent":["let consumer\n\nexport async function getConsumer() {\n  return consumer || setConsumer(createConsumer().then(setConsumer))\n}\n\nexport function setConsumer(newConsumer) {\n  return consumer = newConsumer\n}\n\nexport async function createConsumer() {\n  const { createConsumer } = await import(/* webpackChunkName: \"actioncable\" */ \"@rails/actioncable/src\")\n  return createConsumer()\n}\n\nexport async function subscribeTo(channel, mixin) {\n  const { subscriptions } = await getConsumer()\n  return subscriptions.create(channel, mixin)\n}\n","import { connectStreamSource, disconnectStreamSource } from \"@hotwired/turbo\"\nimport { subscribeTo } from \"./cable\"\n\nclass TurboCableStreamSourceElement extends HTMLElement {\n  async connectedCallback() {\n    connectStreamSource(this)\n    this.subscription = await subscribeTo(this.channel, { received: this.dispatchMessageEvent.bind(this) })\n  }\n\n  disconnectedCallback() {\n    disconnectStreamSource(this)\n    if (this.subscription) this.subscription.unsubscribe()\n  }\n\n  dispatchMessageEvent(data) {\n    const event = new MessageEvent(\"message\", { data })\n    return this.dispatchEvent(event)\n  }\n\n  get channel() {\n    const channel = this.getAttribute(\"channel\")\n    const signed_stream_name = this.getAttribute(\"signed-stream-name\")\n    return { channel, signed_stream_name }\n  }\n}\n\ncustomElements.define(\"turbo-cable-stream-source\", TurboCableStreamSourceElement)\n","export default {\n  logger: self.console,\n  WebSocket: self.WebSocket\n}\n","import adapters from \"./adapters\"\n\n// The logger is disabled by default. You can enable it with:\n//\n//   ActionCable.logger.enabled = true\n//\n//   Example:\n//\n//   import * as ActionCable from '@rails/actioncable'\n//\n//   ActionCable.logger.enabled = true\n//   ActionCable.logger.log('Connection Established.')\n//\n\nexport default {\n  log(...messages) {\n    if (this.enabled) {\n      messages.push(Date.now())\n      adapters.logger.log(\"[ActionCable]\", ...messages)\n    }\n  },\n}\n","import logger from \"./logger\"\n\n// Responsible for ensuring the cable connection is in good health by validating the heartbeat pings sent from the server, and attempting\n// revival reconnections if things go astray. Internal class, not intended for direct user manipulation.\n\nconst now = () => new Date().getTime()\n\nconst secondsSince = time => (now() - time) / 1000\n\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this)\n    this.connection = connection\n    this.reconnectAttempts = 0\n  }\n\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now()\n      delete this.stoppedAt\n      this.startPolling()\n      addEventListener(\"visibilitychange\", this.visibilityDidChange)\n      logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`)\n    }\n  }\n\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now()\n      this.stopPolling()\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange)\n      logger.log(\"ConnectionMonitor stopped\")\n    }\n  }\n\n  isRunning() {\n    return this.startedAt && !this.stoppedAt\n  }\n\n  recordPing() {\n    this.pingedAt = now()\n  }\n\n  recordConnect() {\n    this.reconnectAttempts = 0\n    this.recordPing()\n    delete this.disconnectedAt\n    logger.log(\"ConnectionMonitor recorded connect\")\n  }\n\n  recordDisconnect() {\n    this.disconnectedAt = now()\n    logger.log(\"ConnectionMonitor recorded disconnect\")\n  }\n\n  // Private\n\n  startPolling() {\n    this.stopPolling()\n    this.poll()\n  }\n\n  stopPolling() {\n    clearTimeout(this.pollTimeout)\n  }\n\n  poll() {\n    this.pollTimeout = setTimeout(() => {\n      this.reconnectIfStale()\n      this.poll()\n    }\n    , this.getPollInterval())\n  }\n\n  getPollInterval() {\n    const { staleThreshold, reconnectionBackoffRate } = this.constructor\n    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10))\n    const jitterMax = this.reconnectAttempts === 0 ? 1.0 : reconnectionBackoffRate\n    const jitter = jitterMax * Math.random()\n    return staleThreshold * 1000 * backoff * (1 + jitter)\n  }\n\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`)\n      this.reconnectAttempts++\n      if (this.disconnectedRecently()) {\n        logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`)\n      } else {\n        logger.log(\"ConnectionMonitor reopening\")\n        this.connection.reopen()\n      }\n    }\n  }\n\n  get refreshedAt() {\n    return this.pingedAt ? this.pingedAt : this.startedAt\n  }\n\n  connectionIsStale() {\n    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold\n  }\n\n  disconnectedRecently() {\n    return this.disconnectedAt && (secondsSince(this.disconnectedAt) < this.constructor.staleThreshold)\n  }\n\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout(() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`)\n          this.connection.reopen()\n        }\n      }\n      , 200)\n    }\n  }\n\n}\n\nConnectionMonitor.staleThreshold = 6 // Server::Connections::BEAT_INTERVAL * 2 (missed two pings)\nConnectionMonitor.reconnectionBackoffRate = 0.15\n\nexport default ConnectionMonitor\n","export default {\n  \"message_types\": {\n    \"welcome\": \"welcome\",\n    \"disconnect\": \"disconnect\",\n    \"ping\": \"ping\",\n    \"confirmation\": \"confirm_subscription\",\n    \"rejection\": \"reject_subscription\"\n  },\n  \"disconnect_reasons\": {\n    \"unauthorized\": \"unauthorized\",\n    \"invalid_request\": \"invalid_request\",\n    \"server_restart\": \"server_restart\"\n  },\n  \"default_mount_path\": \"/cable\",\n  \"protocols\": [\n    \"actioncable-v1-json\",\n    \"actioncable-unsupported\"\n  ]\n}\n","import adapters from \"./adapters\"\nimport ConnectionMonitor from \"./connection_monitor\"\nimport INTERNAL from \"./internal\"\nimport logger from \"./logger\"\n\n// Encapsulate the cable connection held by the consumer. This is an internal class not intended for direct user manipulation.\n\nconst {message_types, protocols} = INTERNAL\nconst supportedProtocols = protocols.slice(0, protocols.length - 1)\n\nconst indexOf = [].indexOf\n\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this)\n    this.consumer = consumer\n    this.subscriptions = this.consumer.subscriptions\n    this.monitor = new ConnectionMonitor(this)\n    this.disconnected = true\n  }\n\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data))\n      return true\n    } else {\n      return false\n    }\n  }\n\n  open() {\n    if (this.isActive()) {\n      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`)\n      return false\n    } else {\n      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols}`)\n      if (this.webSocket) { this.uninstallEventHandlers() }\n      this.webSocket = new adapters.WebSocket(this.consumer.url, protocols)\n      this.installEventHandlers()\n      this.monitor.start()\n      return true\n    }\n  }\n\n  close({allowReconnect} = {allowReconnect: true}) {\n    if (!allowReconnect) { this.monitor.stop() }\n    if (this.isActive()) {\n      return this.webSocket.close()\n    }\n  }\n\n  reopen() {\n    logger.log(`Reopening WebSocket, current state is ${this.getState()}`)\n    if (this.isActive()) {\n      try {\n        return this.close()\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error)\n      }\n      finally {\n        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`)\n        setTimeout(this.open, this.constructor.reopenDelay)\n      }\n    } else {\n      return this.open()\n    }\n  }\n\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol\n    }\n  }\n\n  isOpen() {\n    return this.isState(\"open\")\n  }\n\n  isActive() {\n    return this.isState(\"open\", \"connecting\")\n  }\n\n  // Private\n\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0\n  }\n\n  isState(...states) {\n    return indexOf.call(states, this.getState()) >= 0\n  }\n\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase()\n        }\n      }\n    }\n    return null\n  }\n\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this)\n      this.webSocket[`on${eventName}`] = handler\n    }\n  }\n\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[`on${eventName}`] = function() {}\n    }\n  }\n\n}\n\nConnection.reopenDelay = 500\n\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) { return }\n    const {identifier, message, reason, reconnect, type} = JSON.parse(event.data)\n    switch (type) {\n      case message_types.welcome:\n        this.monitor.recordConnect()\n        return this.subscriptions.reload()\n      case message_types.disconnect:\n        logger.log(`Disconnecting. Reason: ${reason}`)\n        return this.close({allowReconnect: reconnect})\n      case message_types.ping:\n        return this.monitor.recordPing()\n      case message_types.confirmation:\n        this.subscriptions.confirmSubscription(identifier)\n        return this.subscriptions.notify(identifier, \"connected\")\n      case message_types.rejection:\n        return this.subscriptions.reject(identifier)\n      default:\n        return this.subscriptions.notify(identifier, \"received\", message)\n    }\n  },\n\n  open() {\n    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`)\n    this.disconnected = false\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\")\n      return this.close({allowReconnect: false})\n    }\n  },\n\n  close(event) {\n    logger.log(\"WebSocket onclose event\")\n    if (this.disconnected) { return }\n    this.disconnected = true\n    this.monitor.recordDisconnect()\n    return this.subscriptions.notifyAll(\"disconnected\", {willAttemptReconnect: this.monitor.isRunning()})\n  },\n\n  error() {\n    logger.log(\"WebSocket onerror event\")\n  }\n}\n\nexport default Connection\n","// A new subscription is created through the ActionCable.Subscriptions instance available on the consumer.\n// It provides a number of callbacks and a method for calling remote procedure calls on the corresponding\n// Channel instance on the server side.\n//\n// An example demonstrates the basic functionality:\n//\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\", {\n//     connected() {\n//       // Called once the subscription has been successfully completed\n//     },\n//\n//     disconnected({ willAttemptReconnect: boolean }) {\n//       // Called when the client has disconnected with the server.\n//       // The object will have an `willAttemptReconnect` property which\n//       // says whether the client has the intention of attempting\n//       // to reconnect.\n//     },\n//\n//     appear() {\n//       this.perform('appear', {appearing_on: this.appearingOn()})\n//     },\n//\n//     away() {\n//       this.perform('away')\n//     },\n//\n//     appearingOn() {\n//       $('main').data('appearing-on')\n//     }\n//   })\n//\n// The methods #appear and #away forward their intent to the remote AppearanceChannel instance on the server\n// by calling the `perform` method with the first parameter being the action (which maps to AppearanceChannel#appear/away).\n// The second parameter is a hash that'll get JSON encoded and made available on the server in the data parameter.\n//\n// This is how the server component would look:\n//\n//   class AppearanceChannel < ApplicationActionCable::Channel\n//     def subscribed\n//       current_user.appear\n//     end\n//\n//     def unsubscribed\n//       current_user.disappear\n//     end\n//\n//     def appear(data)\n//       current_user.appear on: data['appearing_on']\n//     end\n//\n//     def away\n//       current_user.away\n//     end\n//   end\n//\n// The \"AppearanceChannel\" name is automatically mapped between the client-side subscription creation and the server-side Ruby class name.\n// The AppearanceChannel#appear/away public methods are exposed automatically to client-side invocation through the perform method.\n\nconst extend = function(object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key]\n      object[key] = value\n    }\n  }\n  return object\n}\n\nexport default class Subscription {\n  constructor(consumer, params = {}, mixin) {\n    this.consumer = consumer\n    this.identifier = JSON.stringify(params)\n    extend(this, mixin)\n  }\n\n  // Perform a channel action with the optional data passed as an attribute\n  perform(action, data = {}) {\n    data.action = action\n    return this.send(data)\n  }\n\n  send(data) {\n    return this.consumer.send({command: \"message\", identifier: this.identifier, data: JSON.stringify(data)})\n  }\n\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this)\n  }\n}\n","import logger from \"./logger\"\n\n// Responsible for ensuring channel subscribe command is confirmed, retrying until confirmation is received.\n// Internal class, not intended for direct user manipulation.\n\nclass SubscriptionGuarantor {\n  constructor(subscriptions) {\n    this.subscriptions = subscriptions\n    this.pendingSubscriptions = []\n  }\n\n  guarantee(subscription) {\n    if(this.pendingSubscriptions.indexOf(subscription) == -1){ \n      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`)\n      this.pendingSubscriptions.push(subscription) \n    }\n    else {\n      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`)\n    }\n    this.startGuaranteeing()\n  }\n\n  forget(subscription) {\n    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`)\n    this.pendingSubscriptions = (this.pendingSubscriptions.filter((s) => s !== subscription))\n  }\n\n  startGuaranteeing() {\n    this.stopGuaranteeing()\n    this.retrySubscribing()\n  }\n  \n  stopGuaranteeing() {\n    clearTimeout(this.retryTimeout)\n  }\n\n  retrySubscribing() {\n    this.retryTimeout = setTimeout(() => {\n      if (this.subscriptions && typeof(this.subscriptions.subscribe) === \"function\") {\n        this.pendingSubscriptions.map((subscription) => {\n          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`)\n          this.subscriptions.subscribe(subscription)\n        })\n      }\n    }\n    , 500)\n  }\n}\n\nexport default SubscriptionGuarantor","import Subscription from \"./subscription\"\nimport SubscriptionGuarantor from \"./subscription_guarantor\"\nimport logger from \"./logger\"\n\n// Collection class for creating (and internally managing) channel subscriptions.\n// The only method intended to be triggered by the user is ActionCable.Subscriptions#create,\n// and it should be called through the consumer like so:\n//\n//   App = {}\n//   App.cable = ActionCable.createConsumer(\"ws://example.com/accounts/1\")\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\")\n//\n// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.\n\nexport default class Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer\n    this.guarantor = new SubscriptionGuarantor(this)\n    this.subscriptions = []\n  }\n\n  create(channelName, mixin) {\n    const channel = channelName\n    const params = typeof channel === \"object\" ? channel : {channel}\n    const subscription = new Subscription(this.consumer, params, mixin)\n    return this.add(subscription)\n  }\n\n  // Private\n\n  add(subscription) {\n    this.subscriptions.push(subscription)\n    this.consumer.ensureActiveConnection()\n    this.notify(subscription, \"initialized\")\n    this.subscribe(subscription)\n    return subscription\n  }\n\n  remove(subscription) {\n    this.forget(subscription)\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\")\n    }\n    return subscription\n  }\n\n  reject(identifier) {\n    return this.findAll(identifier).map((subscription) => {\n      this.forget(subscription)\n      this.notify(subscription, \"rejected\")\n      return subscription\n    })\n  }\n\n  forget(subscription) {\n    this.guarantor.forget(subscription)\n    this.subscriptions = (this.subscriptions.filter((s) => s !== subscription))\n    return subscription\n  }\n\n  findAll(identifier) {\n    return this.subscriptions.filter((s) => s.identifier === identifier)\n  }\n\n  reload() {\n    return this.subscriptions.map((subscription) =>\n      this.subscribe(subscription))\n  }\n\n  notifyAll(callbackName, ...args) {\n    return this.subscriptions.map((subscription) =>\n      this.notify(subscription, callbackName, ...args))\n  }\n\n  notify(subscription, callbackName, ...args) {\n    let subscriptions\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription)\n    } else {\n      subscriptions = [subscription]\n    }\n\n    return subscriptions.map((subscription) =>\n      (typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined))\n  }\n\n  subscribe(subscription) {\n    if (this.sendCommand(subscription, \"subscribe\")) {\n      this.guarantor.guarantee(subscription)\n    }\n  }\n\n  confirmSubscription(identifier) {\n    logger.log(`Subscription confirmed ${identifier}`)\n    this.findAll(identifier).map((subscription) =>\n      this.guarantor.forget(subscription))\n  }\n\n  sendCommand(subscription, command) {\n    const {identifier} = subscription\n    return this.consumer.send({command, identifier})\n  }\n}\n","import Connection from \"./connection\"\nimport Subscriptions from \"./subscriptions\"\n\n// The ActionCable.Consumer establishes the connection to a server-side Ruby Connection object. Once established,\n// the ActionCable.ConnectionMonitor will ensure that its properly maintained through heartbeats and checking for stale updates.\n// The Consumer instance is also the gateway to establishing subscriptions to desired channels through the #createSubscription\n// method.\n//\n// The following example shows how this can be set up:\n//\n//   App = {}\n//   App.cable = ActionCable.createConsumer(\"ws://example.com/accounts/1\")\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\")\n//\n// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.\n//\n// When a consumer is created, it automatically connects with the server.\n//\n// To disconnect from the server, call\n//\n//   App.cable.disconnect()\n//\n// and to restart the connection:\n//\n//   App.cable.connect()\n//\n// Any channel subscriptions which existed prior to disconnecting will\n// automatically resubscribe.\n\nexport default class Consumer {\n  constructor(url) {\n    this._url = url\n    this.subscriptions = new Subscriptions(this)\n    this.connection = new Connection(this)\n  }\n\n  get url() {\n    return createWebSocketURL(this._url)\n  }\n\n  send(data) {\n    return this.connection.send(data)\n  }\n\n  connect() {\n    return this.connection.open()\n  }\n\n  disconnect() {\n    return this.connection.close({allowReconnect: false})\n  }\n\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open()\n    }\n  }\n}\n\nexport function createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url()\n  }\n\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\")\n    a.href = url\n    // Fix populating Location properties in IE. Otherwise, protocol will be blank.\n    a.href = a.href\n    a.protocol = a.protocol.replace(\"http\", \"ws\")\n    return a.href\n  } else {\n    return url\n  }\n}\n","import Connection from \"./connection\"\nimport ConnectionMonitor from \"./connection_monitor\"\nimport Consumer, { createWebSocketURL } from \"./consumer\"\nimport INTERNAL from \"./internal\"\nimport Subscription from \"./subscription\"\nimport Subscriptions from \"./subscriptions\"\nimport SubscriptionGuarantor from \"./subscription_guarantor\"\nimport adapters from \"./adapters\"\nimport logger from \"./logger\"\n\nexport {\n  Connection,\n  ConnectionMonitor,\n  Consumer,\n  INTERNAL,\n  Subscription,\n  Subscriptions,\n  SubscriptionGuarantor,\n  adapters,\n  createWebSocketURL,\n  logger,\n}\n\nexport function createConsumer(url = getConfig(\"url\") || INTERNAL.default_mount_path) {\n  return new Consumer(url)\n}\n\nexport function getConfig(name) {\n  const element = document.head.querySelector(`meta[name='action-cable-${name}']`)\n  if (element) {\n    return element.getAttribute(\"content\")\n  }\n}\n"],"names":["consumer","async","getConsumer","setConsumer","createConsumer","then","newConsumer","Promise","subscribeTo","channel","mixin","subscriptions","create","TurboCableStreamSourceElement","HTMLElement","[object Object]","connectStreamSource","this","subscription","received","dispatchMessageEvent","bind","disconnectStreamSource","unsubscribe","data","event","MessageEvent","dispatchEvent","getAttribute","signed_stream_name","customElements","define","logger","self","console","WebSocket","messages","enabled","push","Date","now","adapters","log","getTime","secondsSince","time","ConnectionMonitor","connection","visibilityDidChange","reconnectAttempts","isRunning","startedAt","stoppedAt","startPolling","addEventListener","constructor","staleThreshold","stopPolling","removeEventListener","pingedAt","recordPing","disconnectedAt","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","getPollInterval","reconnectionBackoffRate","Math","pow","min","random","connectionIsStale","refreshedAt","disconnectedRecently","reopen","document","visibilityState","isOpen","message_types","welcome","disconnect","ping","confirmation","rejection","disconnect_reasons","unauthorized","invalid_request","server_restart","default_mount_path","protocols","INTERNAL","supportedProtocols","slice","length","indexOf","Connection","open","monitor","disconnected","webSocket","send","JSON","stringify","isActive","getState","uninstallEventHandlers","url","installEventHandlers","start","allowReconnect","stop","close","error","reopenDelay","protocol","isState","call","getProtocol","states","state","readyState","toLowerCase","eventName","events","handler","prototype","isProtocolSupported","identifier","message","reason","reconnect","type","parse","recordConnect","reload","confirmSubscription","notify","reject","recordDisconnect","notifyAll","willAttemptReconnect","Subscription","params","object","properties","key","value","extend","action","command","remove","SubscriptionGuarantor","pendingSubscriptions","startGuaranteeing","filter","s","stopGuaranteeing","retrySubscribing","retryTimeout","map","subscribe","Subscriptions","guarantor","channelName","add","ensureActiveConnection","forget","findAll","sendCommand","callbackName","args","undefined","guarantee","Consumer","_url","createWebSocketURL","test","a","createElement","href","replace","getConfig","name","element","head","querySelector"],"mappings":"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"}